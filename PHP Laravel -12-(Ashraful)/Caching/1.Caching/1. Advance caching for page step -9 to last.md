# Laravel Caching: Complete Tutorial

## Introduction

Laravel caching allows you to store frequently accessed data in fast storage systems like Redis or Memcached. This tutorial will show you how to implement caching for articles where users always get updated data, and the cache automatically refreshes when articles are created, updated, or deleted.

## Step 1: Configure Cache Driver

### Update your `.env` file:
```env
CACHE_DRIVER=redis
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379
```

### Install Redis package:
```bash
composer require predis/predis
```

### Configure `config/cache.php`:
```php
'default' => env('CACHE_DRIVER', 'redis'),

'stores' => [
    'redis' => [
        'driver' => 'redis',
        'connection' => 'cache',
        'lock_connection' => 'default',
    ],
    // ... other stores
],
```

**Why Redis/Memcached?** These are memory-based storage systems that are much faster than file-based caching.

## Step 2: Basic Caching Operations

### Retrieve data from cache:
```php
use Illuminate\Support\Facades\Cache;

// Get value from cache
$value = Cache::get('key');

// Get with default value
$value = Cache::get('key', 'default_value');

// Get with closure as default
$articles = Cache::get('articles', function() {
    return Article::with('user', 'category')->get();
});
```

### Check if data exists in cache:
```php
if (Cache::has('articles')) {
    $articles = Cache::get('articles');
} else {
    // Fetch from database and cache it
}
```

### Store data with expiration:
```php
// Store for 60 minutes
Cache::remember('articles', 60, function() {
    return Article::with('user', 'category')
                 ->orderBy('created_at', 'desc')
                 ->take(20)
                 ->get();
});
```

### Store data permanently:
```php
Cache::rememberForever('articles', function() {
    return Article::with('user', 'category')->get();
});
```

### Other useful methods:
```php
// Store data
Cache::put('key', $value, 60); // 60 minutes

// Add data only if key doesn't exist
Cache::add('key', $value, 60);

// Store forever
Cache::forever('key', $value);

// Retrieve and delete
$value = Cache::pull('key');

// Delete specific key
Cache::forget('key');

// Clear all cache
Cache::flush();
```

### Helper methods:
```php
// Short syntax for getting cache
$value = cache('key');

// Get with default closure
$value = cache('key', function() {
    return expensive_operation();
});

// Store with helper
cache(['key' => 'value'], 60); // 60 minutes
```

## Step 3: Create Article Model with Events

### Update your Article model:
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Events\ArticleCreated;
use App\Events\ArticleUpdated;
use App\Events\ArticleDeleted;

class Article extends Model
{
    protected $fillable = ['title', 'content', 'user_id', 'category_id'];

    // Dispatch events automatically
    protected $dispatchesEvents = [
        'created' => ArticleCreated::class,
        'updated' => ArticleUpdated::class,
        'deleted' => ArticleDeleted::class,
    ];

    // Relationships
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    public function category()
    {
        return $this->belongsTo(Category::class);
    }
}
```

## Step 4: Create Events

### Generate events:
```bash
php artisan make:event ArticleCreated
php artisan make:event ArticleUpdated
php artisan make:event ArticleDeleted
```

### Example ArticleCreated event:
```php
<?php

namespace App\Events;

use App\Models\Article;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class ArticleCreated
{
    use Dispatchable, SerializesModels;

    public $article;

    public function __construct(Article $article)
    {
        $this->article = $article;
    }
}
```

**Note:** Create similar events for `ArticleUpdated` and `ArticleDeleted`.

## Step 5: Create Cache Listener

### Generate listener:
```bash
php artisan make:listener ArticleCacheListener
```

### Implement the listener:
```php
<?php

namespace App\Listeners;

use Illuminate\Support\Facades\Cache;
use App\Models\Article;
use Illuminate\Support\Facades\Log;

class ArticleCacheListener
{
    public function handle($event)
    {
        // Clear the existing cache
        Cache::forget('articles');
        
        // Refresh cache with updated data
        $articles = Article::with('user', 'category')
                          ->orderBy('created_at', 'desc')
                          ->take(20)
                          ->get();
        
        Cache::forever('articles', $articles);
        
        // Log for debugging
        Log::info('Articles cache refreshed', [
            'count' => $articles->count(),
            'triggered_by' => class_basename($event)
        ]);
    }
}
```

## Step 6: Register Events and Listeners

### Update `app/Providers/EventServiceProvider.php`:
```php
<?php

namespace App\Providers;

use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;
use App\Events\ArticleCreated;
use App\Events\ArticleUpdated;
use App\Events\ArticleDeleted;
use App\Listeners\ArticleCacheListener;

class EventServiceProvider extends ServiceProvider
{
    protected $listen = [
        ArticleCreated::class => [
            ArticleCacheListener::class,
        ],
        ArticleUpdated::class => [
            ArticleCacheListener::class,
        ],
        ArticleDeleted::class => [
            ArticleCacheListener::class,
        ],
    ];

    public function boot()
    {
        //
    }
}
```

## Step 7: Implement in Controller

### ArticleController example:
```php
<?php

namespace App\Http\Controllers;

use App\Models\Article;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;

class ArticleController extends Controller
{
    public function index()
    {
        // Always get from cache, cache is automatically updated via events
        $articles = Cache::rememberForever('articles', function() {
            return Article::with('user', 'category')
                          ->orderBy('created_at', 'desc')
                          ->take(20)
                          ->get();
        });

        return view('articles.index', compact('articles'));
    }

    public function show(Article $article)
    {
        // Cache individual articles
        $cachedArticle = Cache::remember("article.{$article->id}", 60, function() use ($article) {
            return $article->load('user', 'category');
        });

        return view('articles.show', compact('cachedArticle'));
    }

    public function store(Request $request)
    {
        $request->validate([
            'title' => 'required|max:255',
            'content' => 'required',
            'category_id' => 'required|exists:categories,id'
        ]);

        // Create article - this will automatically trigger cache refresh
        Article::create([
            'title' => $request->title,
            'content' => $request->content,
            'category_id' => $request->category_id,
            'user_id' => auth()->id(),
        ]);

        return redirect()->route('articles.index')->with('success', 'Article created successfully!');
    }

    public function update(Request $request, Article $article)
    {
        $request->validate([
            'title' => 'required|max:255',
            'content' => 'required',
            'category_id' => 'required|exists:categories,id'
        ]);

        // Update article - this will automatically trigger cache refresh
        $article->update($request->only(['title', 'content', 'category_id']));

        // Clear individual article cache
        Cache::forget("article.{$article->id}");

        return redirect()->route('articles.show', $article)->with('success', 'Article updated successfully!');
    }

    public function destroy(Article $article)
    {
        // Delete article - this will automatically trigger cache refresh
        $article->delete();

        // Clear individual article cache
        Cache::forget("article.{$article->id}");

        return redirect()->route('articles.index')->with('success', 'Article deleted successfully!');
    }
}
```

## Step 8: Advanced Caching Strategies

### Cache Tags (for Redis/Memcached):
```php
// Store with tags
Cache::tags(['articles', 'posts'])->put('article.1', $article, 60);

// Flush all cached items with specific tag
Cache::tags(['articles'])->flush();
```

### Cache with different keys for different scenarios:
```php
class ArticleService
{
    public function getLatestArticles($limit = 20)
    {
        return Cache::remember("articles.latest.{$limit}", 60, function() use ($limit) {
            return Article::with('user', 'category')
                          ->orderBy('created_at', 'desc')
                          ->take($limit)
                          ->get();
        });
    }

    public function getArticlesByCategory($categoryId)
    {
        return Cache::remember("articles.category.{$categoryId}", 60, function() use ($categoryId) {
            return Article::with('user', 'category')
                          ->where('category_id', $categoryId)
                          ->orderBy('created_at', 'desc')
                          ->get();
        });
    }
}
```

## Best Practices

### 1. Use descriptive cache keys:
```php
// Good
Cache::remember('articles.latest.20', 60, $callback);
Cache::remember("user.{$userId}.profile", 60, $callback);

// Bad
Cache::remember('data', 60, $callback);
Cache::remember('stuff', 60, $callback);
```

### 2. Set appropriate expiration times:
```php
// Frequently changing data - short cache
Cache::remember('live.stock.prices', 1, $callback); // 1 minute

// Rarely changing data - longer cache
Cache::remember('site.settings', 1440, $callback); // 24 hours

// Static data - forever (until manually cleared)
Cache::rememberForever('countries.list', $callback);
```

### 3. Handle cache failures gracefully:
```php
try {
    $articles = Cache::remember('articles', 60, function() {
        return Article::latest()->take(20)->get();
    });
} catch (\Exception $e) {
    // Fallback to database if cache fails
    Log::error('Cache error: ' . $e->getMessage());
    $articles = Article::latest()->take(20)->get();
}
```

### 4. Use cache for expensive operations:
```php
// Cache complex queries
$stats = Cache::remember('dashboard.stats', 60, function() {
    return [
        'total_articles' => Article::count(),
        'published_articles' => Article::where('status', 'published')->count(),
        'total_users' => User::count(),
        'popular_articles' => Article::withCount('views')
                                   ->orderBy('views_count', 'desc')
                                   ->take(5)
                                   ->get()
    ];
});
```

## Testing Your Cache Implementation

### Check if cache is working:
```php
// In tinker or a test route
php artisan tinker

// Test cache operations
Cache::put('test', 'Hello World', 60);
$value = Cache::get('test'); // Should return "Hello World"
Cache::forget('test');
$value = Cache::get('test'); // Should return null
```

### Monitor cache in logs:
Check your `storage/logs/laravel.log` for the cache refresh messages from the listener.

## Step 9: Page/View Caching (Full Page Cache)

### Create Page Cache Middleware

Generate middleware for page caching:
```bash
php artisan make:middleware PageCacheMiddleware
```

### Implement Page Cache Middleware:
```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Auth;

class PageCacheMiddleware
{
    public function handle(Request $request, Closure $next, $duration = 60)
    {
        // Don't cache for authenticated users or POST requests
        if (Auth::check() || !$request->isMethod('GET')) {
            return $next($request);
        }

        // Create unique cache key for this page
        $cacheKey = $this->getCacheKey($request);
        
        // Check if page is cached
        if (Cache::has($cacheKey)) {
            $cachedResponse = Cache::get($cacheKey);
            return response($cachedResponse['content'])
                ->withHeaders($cachedResponse['headers']);
        }

        // Get response from next middleware/controller
        $response = $next($request);
        
        // Only cache successful responses
        if ($response->getStatusCode() == 200) {
            $cacheData = [
                'content' => $response->getContent(),
                'headers' => $response->headers->all()
            ];
            
            Cache::put($cacheKey, $cacheData, $duration);
        }

        return $response;
    }

    private function getCacheKey(Request $request)
    {
        // Include URL, query parameters, and user type in cache key
        $url = $request->url();
        $query = $request->getQueryString();
        $userType = Auth::check() ? 'auth' : 'guest';
        
        return 'page_cache:' . md5($url . $query . $userType);
    }
}
```

### Register Middleware in `app/Http/Kernel.php`:
```php
protected $middlewareAliases = [
    // ... other middleware
    'page.cache' => \App\Http\Middleware\PageCacheMiddleware::class,
];
```

### Apply to Routes:
```php
// In routes/web.php

// Cache homepage for 30 minutes
Route::get('/', [HomeController::class, 'index'])
    ->middleware('page.cache:30');

// Cache article pages for 60 minutes  
Route::get('/articles', [ArticleController::class, 'index'])
    ->middleware('page.cache:60');

Route::get('/articles/{article}', [ArticleController::class, 'show'])
    ->middleware('page.cache:120');

// Cache category pages for 45 minutes
Route::get('/categories/{category}', [CategoryController::class, 'show'])
    ->middleware('page.cache:45');
```

## Step 10: Advanced Page Caching Strategies

### Method 1: Response Caching in Controller
```php
<?php

namespace App\Http\Controllers;

use App\Models\Article;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;

class ArticleController extends Controller
{
    public function index(Request $request)
    {
        // Create cache key based on page and query parameters
        $page = $request->get('page', 1);
        $cacheKey = "articles.index.page.{$page}";
        
        return Cache::remember($cacheKey, 60, function() {
            $articles = Cache::rememberForever('articles', function() {
                return Article::with('user', 'category')
                              ->orderBy('created_at', 'desc')
                              ->paginate(10);
            });

            return view('articles.index', compact('articles'));
        });
    }

    public function show(Article $article)
    {
        $cacheKey = "article.page.{$article->id}";
        
        return Cache::remember($cacheKey, 120, function() use ($article) {
            $article->load('user', 'category', 'comments.user');
            return view('articles.show', compact('article'));
        });
    }
}
```

### Method 2: View Fragment Caching
```php
<!-- In your Blade templates -->

<!-- Cache article list fragment -->
@cache('articles.list', $articles)
    @foreach($articles as $article)
        <div class="article-card">
            <h3>{{ $article->title }}</h3>
            <p>{{ Str::limit($article->content, 150) }}</p>
            <small>By {{ $article->user->name }} on {{ $article->created_at->format('M d, Y') }}</small>
        </div>
    @endforeach
@endcache

<!-- Cache sidebar -->
@cache('sidebar.popular', null, 30)
    <div class="sidebar">
        <h4>Popular Articles</h4>
        @foreach(App\Models\Article::popular()->take(5)->get() as $popular)
            <a href="{{ route('articles.show', $popular) }}">{{ $popular->title }}</a>
        @endforeach
    </div>
@endcache
```

### Method 3: Full Response Caching with Cache Helper
```php
class ArticleController extends Controller
{
    public function index()
    {
        return $this->cacheResponse('articles.index', 60, function() {
            $articles = Cache::rememberForever('articles', function() {
                return Article::with('user', 'category')
                              ->orderBy('created_at', 'desc')
                              ->paginate(10);
            });

            return view('articles.index', compact('articles'));
        });
    }

    private function cacheResponse($key, $minutes, $callback)
    {
        return Cache::remember($key, $minutes, function() use ($callback) {
            $response = $callback();
            return $response instanceof \Illuminate\View\View 
                ? $response->render() 
                : $response;
        });
    }
}
```

## Step 11: Smart Cache Invalidation for Pages

### Update ArticleCacheListener for Page Cache:
```php
<?php

namespace App\Listeners;

use Illuminate\Support\Facades\Cache;
use App\Models\Article;
use Illuminate\Support\Facades\Log;

class ArticleCacheListener
{
    public function handle($event)
    {
        // Clear data cache
        Cache::forget('articles');
        
        // Clear page cache patterns
        $this->clearPageCache();
        
        // Refresh data cache with updated data
        $articles = Article::with('user', 'category')
                          ->orderBy('created_at', 'desc')
                          ->take(20)
                          ->get();
        
        Cache::forever('articles', $articles);
        
        Log::info('Cache cleared and refreshed', [
            'count' => $articles->count(),
            'triggered_by' => class_basename($event)
        ]);
    }

    private function clearPageCache()
    {
        // Clear all article-related page cache
        $patterns = [
            'articles.index*',
            'article.page.*',
            'page_cache:*articles*',
            'sidebar.popular',
        ];

        foreach ($patterns as $pattern) {
            $this->forgetByPattern($pattern);
        }
    }

    private function forgetByPattern($pattern)
    {
        // For Redis, you can use SCAN to find and delete keys
        if (config('cache.default') === 'redis') {
            $redis = Cache::getRedis();
            $keys = $redis->keys(config('cache.prefix') . ':' . $pattern);
            
            if (!empty($keys)) {
                $redis->del($keys);
            }
        } else {
            // For other cache drivers, you might need to keep track of keys
            // or use cache tags if supported
            Cache::flush(); // Less efficient but works
        }
    }
}
```

## Step 12: Cache Warming Strategy

### Create Cache Warming Command:
```bash
php artisan make:command WarmPageCache
```

### Implement Cache Warming:
```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Http;
use App\Models\Article;

class WarmPageCache extends Command
{
    protected $signature = 'cache:warm-pages';
    protected $description = 'Warm up page cache for important pages';

    public function handle()
    {
        $this->info('Starting cache warming...');
        
        $baseUrl = config('app.url');
        
        // Warm up important pages
        $pages = [
            '/',
            '/articles',
        ];

        foreach ($pages as $page) {
            $this->warmPage($baseUrl . $page);
        }

        // Warm up top articles
        $topArticles = Article::orderBy('views', 'desc')->take(10)->get();
        
        foreach ($topArticles as $article) {
            $this->warmPage($baseUrl . "/articles/{$article->id}");
        }

        $this->info('Cache warming completed!');
    }

    private function warmPage($url)
    {
        try {
            Http::get($url);
            $this->line("Warmed: {$url}");
        } catch (\Exception $e) {
            $this->error("Failed to warm: {$url} - " . $e->getMessage());
        }
    }
}
```

### Schedule Cache Warming:
```php
// In app/Console/Kernel.php
protected function schedule(Schedule $schedule)
{
    // Warm cache every hour
    $schedule->command('cache:warm-pages')->hourly();
}
```

## Step 13: User-Specific Page Caching

### For Authenticated Users:
```php
class AuthenticatedPageCacheMiddleware
{
    public function handle(Request $request, Closure $next, $duration = 30)
    {
        if (!Auth::check() || !$request->isMethod('GET')) {
            return $next($request);
        }

        $userId = Auth::id();
        $cacheKey = "user.{$userId}.page." . md5($request->url() . $request->getQueryString());
        
        if (Cache::has($cacheKey)) {
            return response(Cache::get($cacheKey));
        }

        $response = $next($request);
        
        if ($response->getStatusCode() == 200) {
            Cache::put($cacheKey, $response->getContent(), $duration);
        }

        return $response;
    }
}
```

## Step 14: Cache Performance Monitoring

### Add Cache Metrics:
```php
class CacheMetricsMiddleware
{
    public function handle(Request $request, Closure $next)
    {
        $startTime = microtime(true);
        
        $response = $next($request);
        
        $duration = microtime(true) - $startTime;
        
        // Log cache performance
        Log::info('Page Performance', [
            'url' => $request->url(),
            'duration' => round($duration * 1000, 2) . 'ms',
            'cache_hit' => $response->headers->has('X-Cache-Hit'),
            'memory_usage' => round(memory_get_peak_usage() / 1024 / 1024, 2) . 'MB'
        ]);

        return $response;
    }
}
```

### Add Cache Headers:
```php
// In your PageCacheMiddleware, add this when serving from cache:
if (Cache::has($cacheKey)) {
    $cachedResponse = Cache::get($cacheKey);
    return response($cachedResponse['content'])
        ->withHeaders($cachedResponse['headers'])
        ->header('X-Cache-Hit', 'true')
        ->header('X-Cache-Key', $cacheKey);
}
```

## Cache Strategy Summary

### Different Cache Layers:
1. **Data Cache**: Cache database queries and expensive operations
2. **View Cache**: Cache rendered HTML fragments  
3. **Page Cache**: Cache entire page responses
4. **HTTP Cache**: Browser and CDN caching

### Cache Duration Guidelines:
```php
// Static content - 24 hours
Route::get('/about', [PageController::class, 'about'])
    ->middleware('page.cache:1440');

// Dynamic content - 1 hour  
Route::get('/articles', [ArticleController::class, 'index'])
    ->middleware('page.cache:60');

// User-specific content - 15 minutes
Route::get('/dashboard', [DashboardController::class, 'index'])
    ->middleware('auth', 'auth.page.cache:15');

// Frequently changing - 5 minutes
Route::get('/trending', [TrendingController::class, 'index'])
    ->middleware('page.cache:5');
```

## Conclusion

This comprehensive caching implementation ensures that:
- **Fast Page Loads**: Entire pages are served from cache
- **Smart Invalidation**: Cache clears automatically when data changes
- **User Experience**: Lightning-fast subsequent visits to any page
- **Scalability**: Reduced database load and server resources
- **Flexibility**: Different cache strategies for different content types
